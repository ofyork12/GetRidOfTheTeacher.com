 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Squares Game</title>
  <style>
    :root {
      --circle-size: clamp(30px, 6vw, 60px); /* Smaller for up to 625 dots */
      --circle-border: clamp(3px, 0.6vw, 6px);
      --circle-total: calc(var(--circle-size) + var(--circle-border) * 2);
      --section-gap: clamp(30px, 6vw, 60px);
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--section-gap);
      padding: 40px 12px 120px;
      overflow-y: auto;
      -webkit-tap-highlight-color: transparent;
    }
    .game-navigation {
      display: flex;
      gap: 20px;
      margin: 20px 0;
      justify-content: center;
      flex-wrap: wrap;
    }
    .game-nav-button {
      padding: 15px 30px;
      font-size: 18px;
      font-weight: bold;
      background: transparent;
      color: #fff;
      border: 3px solid #fff;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
    }
    .game-nav-button:hover {
      background: #fff;
      color: #000;
    }
    .game-nav-button.active {
      background: #fff;
      color: #000;
    }
    .set {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      width: 100%;
      text-align: center;
    }
    .set > :last-child {
      margin: 0 auto;
    }
    .set h2 {
      margin: 0;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    .set {
      margin-bottom: 40px;
    }
    .answer-display {
      margin-top: 15px;
      font-size: 24px;
      font-weight: bold;
      min-height: 30px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .answer-display.show {
      opacity: 1;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 30px;
      justify-content: center;
    }
    .lang-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }
    .controls button {
      padding: 10px 20px;
      border: 2px solid #fff;
      border-radius: 999px;
      background: transparent;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.3s ease, color 0.3s ease;
    }
    .controls button.active {
      background: #fff;
      color: #000;
    }
    .controls button.dual {
      font-size: 13px;
      padding: 6px 14px;
      opacity: 0.85;
      border-style: dashed;
    }
    .circle {
      width: var(--circle-total);
      height: var(--circle-total);
      border-radius: 50%;
      background: #222;
      border: var(--circle-border) solid #fff;
      cursor: pointer;
      transition: background 0.25s ease;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      outline: none;
    }
    .circle:focus-visible,
    .circle:focus,
    .circle:active {
      outline: none;
    }
    .circle.red { background: #ff0000; }
    .circle.orange { background: #ff6200; }
    .circle.yellow { background: #ffe600; }
    .circle.green { background: #00a12c; }
    .circle.blue { background: #0030ff; }
    .circle.purple { background: #6a1b9a; }
    .circle.brown { background: #7a3b00; }
    .circle.pink { background: #ff3fa6; }
    .circle.sky { background: #38c7ff; }
    .circle.red-final { background: #ff0000; }

    /* Single circle */
    .single-circle {
      width: var(--circle-total);
      height: var(--circle-total);
    }

    /* 2x2 grid (4 circles) */
    .grid-two {
      display: grid;
      grid-template-columns: repeat(2, var(--circle-total));
      grid-template-rows: repeat(2, var(--circle-total));
      gap: 0;
      width: calc(var(--circle-total) * 2);
      height: calc(var(--circle-total) * 2);
    }
    .grid-two .circle {
      position: static;
    }

    /* 3x3 grid (9 circles) */
    .grid-three {
      display: grid;
      grid-template-columns: repeat(3, var(--circle-total));
      grid-template-rows: repeat(3, var(--circle-total));
      gap: 0;
      width: calc(var(--circle-total) * 3);
      height: calc(var(--circle-total) * 3);
    }
    .grid-three .circle {
      position: static;
    }

    /* 4x4 grid (16 circles) */
    .grid-four {
      display: grid;
      grid-template-columns: repeat(4, var(--circle-total));
      grid-template-rows: repeat(4, var(--circle-total));
      gap: 0;
      width: calc(var(--circle-total) * 4);
      height: calc(var(--circle-total) * 4);
    }
    .grid-four .circle {
      position: static;
    }

    /* 5x5 grid (25 circles) */
    .grid-five {
      display: grid;
      grid-template-columns: repeat(5, var(--circle-total));
      grid-template-rows: repeat(5, var(--circle-total));
      gap: 0;
      width: calc(var(--circle-total) * 5);
      height: calc(var(--circle-total) * 5);
    }
    .grid-five .circle {
      position: static;
    }

    /* Dynamic grid classes for larger squares */
    .grid-dynamic {
      display: grid;
      gap: 0;
      cursor: pointer;
    }
    .grid-dynamic .circle {
      position: static;
    }
  </style>
</head>
<body>

  <div class="game-navigation">
    <a href="index.html" class="game-nav-button">← Go Back</a>
    <a href="bigger-smaller.html" class="game-nav-button">Bigger/Smaller</a>
    <a href="squares.html" class="game-nav-button active">Squares</a>
  </div>

  <div class="controls" role="group" aria-label="Language selector">
    <div class="lang-group">
      <button data-lang="en" class="active">English</button>
      <button class="dual" data-mode="sound">Sound</button>
    </div>
    <div class="lang-group">
      <button data-lang="vi">Tiếng Việt</button>
      <button class="dual" data-dual="vi">Tiếng Việt + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="zh">中文</button>
      <button class="dual" data-dual="zh">中文 + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="ko">한국어</button>
      <button class="dual" data-dual="ko">한국어 + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="es">Español</button>
      <button class="dual" data-dual="es">Español + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="fr">Français</button>
      <button class="dual" data-dual="fr">Français + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="hi">हिन्दी</button>
      <button class="dual" data-dual="hi">हिन्दी + English</button>
    </div>
  </div>

  <section class="set" data-square="1" data-base="1">
    <h2>1²</h2>
    <div class="single-circle">
      <div class="circle" id="one"></div>
    </div>
    <div class="answer-display" data-answer="1"></div>
  </section>

  <section class="set" data-square="4" data-base="2">
    <h2>2²</h2>
    <div class="grid-two" id="four">
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
    </div>
    <div class="answer-display" data-answer="4"></div>
  </section>

  <section class="set" data-square="9" data-base="3">
    <h2>3²</h2>
    <div class="grid-three" id="nine">
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
    </div>
    <div class="answer-display" data-answer="9"></div>
  </section>

  <section class="set" data-square="16" data-base="4">
    <h2>4²</h2>
    <div class="grid-four" id="sixteen">
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
    </div>
    <div class="answer-display" data-answer="16"></div>
  </section>

  <section class="set" data-square="25" data-base="5">
    <h2>5²</h2>
    <div class="grid-five" id="square-25"></div>
    <div class="answer-display" data-answer="25"></div>
  </section>

  <div id="moreSquares"></div>

<script>
const COLOR_CLASSES = ["orange","yellow","green","blue","purple","brown","pink","sky","red-final"];
// Generate number words up to 625
const basic = {
  en: ["zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen","twenty"],
  zh: ["零","一","二","三","四","五","六","七","八","九","十","十一","十二","十三","十四","十五","十六","十七","十八","十九","二十"],
  es: ["cero","uno","dos","tres","cuatro","cinco","seis","siete","ocho","nueve","diez","once","doce","trece","catorce","quince","dieciséis","diecisiete","dieciocho","diecinueve","veinte"],
  fr: ["zéro","un","deux","trois","quatre","cinq","six","sept","huit","neuf","dix","onze","douze","treize","quatorze","quinze","seize","dix-sept","dix-huit","dix-neuf","vingt"],
  hi: ["शून्य","एक","दो","तीन","चार","पांच","छह","सात","आठ","नौ","दस","ग्यारह","बारह","तेरह","चौदह","पंद्रह","सोलह","सत्रह","अठारह","उन्नीस","बीस"],
  ko: ["영","일","이","삼","사","오","육","칠","팔","구","십","십일","십이","십삼","십사","십오","십육","십칠","십팔","십구","이십"],
  vi: ["không","một","hai","ba","bốn","năm","sáu","bảy","tám","chín","mười","mười một","mười hai","mười ba","mười bốn","mười lăm","mười sáu","mười bảy","mười tám","mười chín","hai mươi"]
};

// Helper function to generate Vietnamese number words
function generateVietnameseNumber(num) {
  if (num <= 20) {
    return basic.vi[num] || num.toString();
  }
  
  if (num < 100) {
    const tens = Math.floor(num / 10);
    const ones = num % 10;
    let tensWord;
    
    if (tens === 2) {
      tensWord = "hai mươi";
    } else if (tens === 3) {
      tensWord = "ba mươi";
    } else if (tens === 4) {
      tensWord = "bốn mươi";
    } else if (tens === 5) {
      tensWord = "năm mươi";
    } else if (tens === 6) {
      tensWord = "sáu mươi";
    } else if (tens === 7) {
      tensWord = "bảy mươi";
    } else if (tens === 8) {
      tensWord = "tám mươi";
    } else if (tens === 9) {
      tensWord = "chín mươi";
    } else {
      tensWord = basic.vi[tens] + " mươi";
    }
    
    if (ones === 0) {
      return tensWord;
    } else if (ones === 1) {
      return tensWord + " mốt";
    } else if (ones === 5) {
      return tensWord + " lăm";
    } else {
      return tensWord + " " + basic.vi[ones];
    }
  }
  
  if (num < 1000) {
    const hundreds = Math.floor(num / 100);
    const remainder = num % 100;
    const hundredsWord = hundreds === 1 ? "một trăm" : (basic.vi[hundreds] + " trăm");
    
    if (remainder === 0) {
      return hundredsWord;
    } else if (remainder < 10) {
      return hundredsWord + " lẻ " + basic.vi[remainder];
    } else {
      return hundredsWord + " " + generateVietnameseNumber(remainder);
    }
  }
  
  // For numbers >= 1000, use simple format
  return num.toString();
}

function generateNumberWords(max) {
  const words = { en: [], zh: [], es: [], fr: [], hi: [], ko: [], vi: [] };
  
  for (let i = 0; i <= max && i <= 20; i++) {
    Object.keys(words).forEach(lang => {
      words[lang].push(basic[lang][i] || i.toString());
    });
  }
  
  // For numbers > 20, generate proper words
  for (let i = 21; i <= max; i++) {
    words.en.push(i.toString());
    words.zh.push(i.toString());
    words.es.push(i.toString());
    words.fr.push(i.toString());
    words.hi.push(i.toString());
    words.ko.push(i.toString());
    
    // Generate Vietnamese number words properly
    words.vi.push(generateVietnameseNumber(i));
  }
  
  return words;
}

// Helper function to generate Vietnamese number words
const NUMBER_WORDS = generateNumberWords(625);
const LANGUAGE_HINTS = {
  en: "English",
  zh: "zh-CN",
  es: "es",
  fr: "fr",
  hi: "hi",
  ko: "ko-KR",
  vi: "vi-VN"
};
let currentLang = "en";
let preferredVoice = null;
let englishVoice = null;
const dualLang = new Set();
let lastSpokenCount = 0;

function pickVoice(langCode) {
  if (!("speechSynthesis" in window)) return null;
  const voices = window.speechSynthesis.getVoices();
  if (!voices.length) return null;

  const langHint = LANGUAGE_HINTS[langCode] || langCode;
  
  // For Chinese, try to find a good Chinese voice
  if (langCode === "zh") {
    // Try to find Chinese voices, prefer zh-CN
    const chineseVoices = voices.filter(v => 
      v.lang && (v.lang.startsWith("zh-CN") || v.lang.startsWith("zh") || v.lang.includes("Chinese"))
    );
    if (chineseVoices.length > 0) {
      // Prefer zh-CN voices
      const cnVoice = chineseVoices.find(v => v.lang.startsWith("zh-CN"));
      if (cnVoice) return cnVoice;
      return chineseVoices[0];
    }
  }
  
  // For Vietnamese, try to find a good Vietnamese voice
  if (langCode === "vi") {
    const vietnameseVoices = voices.filter(v => 
      v.lang && (v.lang.startsWith("vi-VN") || v.lang.startsWith("vi") || v.lang.includes("Vietnamese"))
    );
    if (vietnameseVoices.length > 0) {
      // Prefer vi-VN voices
      const vnVoice = vietnameseVoices.find(v => v.lang.startsWith("vi-VN"));
      if (vnVoice) return vnVoice;
      return vietnameseVoices[0];
    }
  }
  
  const langGroup = voices.filter(v => v.lang && v.lang.startsWith(langHint));
  if (langGroup.length) return langGroup[0];

  const fallbacks = [
    "Microsoft Aria Online (Natural) - English (United States)",
    "Google US English",
    "Google UK English Female",
    "Microsoft Zira Desktop - English (United States)"
  ];

  for (const name of fallbacks) {
    const voice = voices.find(v => v.name === name);
    if (voice) return voice;
  }
  return voices.find(v => v.lang && v.lang.startsWith("en")) || voices[0];
}

function initVoices(lang = currentLang) {
  preferredVoice = pickVoice(lang);
  englishVoice = pickVoice("en");
}

if ("speechSynthesis" in window) {
  window.speechSynthesis.onvoiceschanged = initVoices;
  initVoices();
}

function speakNumber(count) {
  const words = NUMBER_WORDS[currentLang] || NUMBER_WORDS.en;
  if (count < 0 || count >= words.length) return;
  if (!("speechSynthesis" in window)) return;
  lastSpokenCount = count;
  
  window.speechSynthesis.cancel();
  window.speechSynthesis.resume();
  const utterance = new SpeechSynthesisUtterance(words[count]);
  utterance.rate = 1.15;
  utterance.pitch = 1;
  utterance.volume = 0.7; // 70% volume
  utterance.lang = LANGUAGE_HINTS[currentLang] || currentLang;
  if (preferredVoice) utterance.voice = preferredVoice;
  
  const isDual = dualLang.has(currentLang);
  const isEnglish = currentLang === 'en';
  
  requestAnimationFrame(() => {
    if (isEnglish) {
      // English only - say it once
      window.speechSynthesis.speak(utterance);
    } else if (isDual) {
      // Dual mode: native first, then English
      utterance.onend = () => {
        const englishWord = NUMBER_WORDS.en[count];
        const follow = new SpeechSynthesisUtterance(englishWord);
        follow.rate = 1.15;
        follow.pitch = 1;
        follow.volume = 0.7; // 70% volume
        follow.lang = LANGUAGE_HINTS.en || "en";
        if (englishVoice) follow.voice = englishVoice;
        window.speechSynthesis.speak(follow);
      };
      window.speechSynthesis.speak(utterance);
    } else {
      // Native only
      window.speechSynthesis.speak(utterance);
    }
  });
}

function setupGroup(selector, palette) {
  const circles = Array.from(document.querySelectorAll(selector));
  const section = circles[0].closest('.set');
  const answerDisplay = section ? section.querySelector('.answer-display') : null;
  let clickCount = 0;

  function refreshColors() {
    circles.forEach(circle => circle.classList.remove(...COLOR_CLASSES));
    const active = circles.filter(circle => circle.classList.contains("red"));
    const color = palette[active.length];

    if (color) {
      active.forEach(circle => circle.classList.add(color));
    }
    return active.length;
  }

  circles.forEach(circle => {
    circle.addEventListener("click", () => {
      const wasActive = circle.classList.contains("red");
      circle.classList.toggle("red");
      const count = refreshColors();
      speakNumber(count);
      
      if (answerDisplay && count > 0 && !wasActive) {
        clickCount++;
        // Check if all dots are filled (count equals the total number of dots in this section)
        const section = circles[0].closest('.set');
        const totalDots = circles.length;
        if (count >= totalDots) {
          const answer = answerDisplay.dataset.answer;
          answerDisplay.textContent = answer;
          answerDisplay.classList.add('show');
        }
      } else if (answerDisplay && count === 0) {
        clickCount = 0;
        answerDisplay.textContent = '';
        answerDisplay.classList.remove('show');
      }
    });
  });
}

// NUMBER 1 – single circle with voice feedback
const single = document.getElementById("one");
const section1 = single.closest('.set');
const answerDisplay1 = section1.querySelector('.answer-display');
single.addEventListener("click", function() {
  this.classList.toggle("red");
  const count = this.classList.contains("red") ? 1 : 0;
  speakNumber(count);
  
  if (count > 0) {
    // All dots are filled (1 dot), show the answer
    answerDisplay1.textContent = '1';
    answerDisplay1.classList.add('show');
  } else {
    answerDisplay1.textContent = '';
    answerDisplay1.classList.remove('show');
  }
});

// Language controls
const buttons = Array.from(document.querySelectorAll(".controls button[data-lang]"));
const dualButtons = Array.from(document.querySelectorAll(".controls button[data-dual]"));

function selectLanguage(lang, useDual, silent = false) {
  const isNewSelection = currentLang !== lang || useDual !== dualLang.has(lang);
  currentLang = lang;
  initVoices(lang);
  dualLang.clear();
  if (useDual && lang !== "en") {
    dualLang.add(lang);
  }
  buttons.forEach(btn => {
    const active = btn.dataset.lang === lang && !useDual;
    btn.classList.toggle("active", active);
  });

  dualButtons.forEach(btn => {
    const active = btn.dataset.dual === lang && useDual;
    btn.classList.toggle("active", active);
  });

  if (!silent && isNewSelection) {
    speakNumber(lastSpokenCount);
  }
}

buttons.forEach(btn => {
  btn.addEventListener("click", () => {
    selectLanguage(btn.dataset.lang, false);
  });
});

dualButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    selectLanguage(btn.dataset.dual, true);
  });
});

selectLanguage("en", false, true);

setupGroup("#four .circle", {2: "orange", 3: "yellow", 4: "green"});
setupGroup("#nine .circle", {2: "orange", 3: "yellow", 4: "green", 5: "blue", 6: "purple", 7: "brown", 8: "pink", 9: "sky"});

// Helper function to get top right corner indices for a grid
function getTopRightCornerIndices(gridSize, count) {
  // Top right corner: top row, rightmost positions
  // For a grid of size n, top row indices are: 0, 1, 2, ..., n-1
  // We want the rightmost 'count' positions: n-1, n-2, ..., n-count
  const indices = [];
  for (let i = 0; i < count && i < gridSize; i++) {
    indices.push(gridSize - 1 - i); // Top row, from right to left
  }
  return indices.sort((a, b) => a - b); // Sort ascending for easier use
}

// Helper to get triangle pattern (3, 2, 1) in top right corner for 6 dots
function getTrianglePatternIndices(gridSize) {
  // Triangle pattern in top-right corner:
  // 3 dots in first row, 2 dots in second row, 1 dot in third row
  // All touching the right side
  // For 4x4: row 0 has cols 1,2,3; row 1 has cols 2,3; row 2 has col 3
  // Indices: [1, 2, 3, 6, 7, 11]
  const indices = [];
  
  // Row 0 (first row): 3 dots - cols gridSize-3, gridSize-2, gridSize-1
  if (gridSize >= 3) {
    indices.push(0 * gridSize + (gridSize - 3));
    indices.push(0 * gridSize + (gridSize - 2));
    indices.push(0 * gridSize + (gridSize - 1));
  }
  
  // Row 1 (second row): 2 dots - cols gridSize-2, gridSize-1
  if (gridSize >= 2) {
    indices.push(1 * gridSize + (gridSize - 2));
    indices.push(1 * gridSize + (gridSize - 1));
  }
  
  // Row 2 (third row): 1 dot - col gridSize-1
  indices.push(2 * gridSize + (gridSize - 1));
  
  return indices;
}

// Helper to get 2x2 square in top right corner
function get2x2TopRightIndices(gridSize) {
  // 2x2 square in top right: rows 0-1, cols gridSize-2 to gridSize-1
  const indices = [];
  for (let row = 0; row < 2 && row < gridSize; row++) {
    for (let col = gridSize - 2; col < gridSize; col++) {
      indices.push(row * gridSize + col);
    }
  }
  return indices;
}

// Helper to get 3x3 square in top right corner
function get3x3TopRightIndices(gridSize) {
  // 3x3 square in top right: rows 0-2, cols gridSize-3 to gridSize-1
  const indices = [];
  for (let row = 0; row < 3 && row < gridSize; row++) {
    for (let col = gridSize - 3; col < gridSize; col++) {
      indices.push(row * gridSize + col);
    }
  }
  return indices;
}

// Helper to get 5 dots pattern (2 in top row, 3 in row below)
function get5DiagonalPatternIndices(gridSize) {
  // 5 dots: 2 dots in top row, 3 dots in row below, all in top-right corner
  // For 5x5: row 0 has cols 3,4; row 1 has cols 2,3,4
  // Indices: [3, 4, 7, 8, 9]
  const indices = [];
  
  // Row 0 (top row): 2 dots - cols gridSize-2, gridSize-1
  if (gridSize >= 2) {
    indices.push(0 * gridSize + (gridSize - 2));
    indices.push(0 * gridSize + (gridSize - 1));
  }
  
  // Row 1 (row below): 3 dots - cols gridSize-3, gridSize-2, gridSize-1
  if (gridSize >= 3) {
    indices.push(1 * gridSize + (gridSize - 3));
    indices.push(1 * gridSize + (gridSize - 2));
    indices.push(1 * gridSize + (gridSize - 1));
  }
  
  return indices;
}

// Helper function to break down a number into components
function breakDownNumber(num) {
  const str = num.toString();
  const components = [];
  
  if (str.length === 2) {
    // Two-digit: tens and ones
    const tens = parseInt(str[0]) * 10;
    const ones = parseInt(str[1]);
    components.push(tens, ones);
  } else if (str.length === 3) {
    // Three-digit: hundreds, tens, ones
    const hundreds = parseInt(str[0]) * 100;
    const tens = parseInt(str[1]) * 10;
    const ones = parseInt(str[2]);
    components.push(hundreds, tens, ones);
  }
  
  return components;
}

// Color mapping for different numbers
const COLOR_MAP = {
  1: "red", 2: "orange", 3: "yellow", 4: "green", 5: "blue",
  6: "purple", 7: "brown", 8: "pink", 9: "sky", 10: "red-final"
};

// NUMBER 16 – two clicks: first 10 red, then 6 purple (triangle in top-right)
let sixteenClickCount = 0;
const sixteenCircles = Array.from(document.querySelectorAll("#sixteen .circle"));
const section16 = sixteenCircles[0].closest('.set');
const answerDisplay16 = section16.querySelector('.answer-display');
let clickCount16 = 0;
const gridSize16 = 4;
const topRightIndices16 = getTrianglePatternIndices(gridSize16); // 6 dots as triangle

sixteenCircles.forEach(circle => {
  circle.addEventListener("click", () => {
    if (sixteenClickCount === 0) {
      // Fill 10 red dots, excluding the top-right triangle area
      const alreadyFilled = new Set();
      sixteenCircles.forEach((c, i) => {
        if (c.classList.contains("red") || c.classList.contains("purple") || 
            c.classList.contains("orange") || c.classList.contains("yellow") ||
            c.classList.contains("green") || c.classList.contains("blue") ||
            c.classList.contains("brown") || c.classList.contains("pink") ||
            c.classList.contains("sky") || c.classList.contains("red-final")) {
          alreadyFilled.add(i);
        }
      });
      
      // Fill from bottom-left, excluding top-right triangle
      // Collect all available indices first, then take 10
      const allIndices = [];
      for (let row = gridSize16 - 1; row >= 0; row--) {
        for (let col = 0; col < gridSize16; col++) {
          const idx = row * gridSize16 + col;
          if (!topRightIndices16.includes(idx) && !alreadyFilled.has(idx)) {
            allIndices.push(idx);
          }
        }
      }
      const indicesToFill = allIndices.slice(0, 10);
      
      indicesToFill.forEach(i => {
        const c = sixteenCircles[i];
        c.classList.remove(...COLOR_CLASSES);
        c.classList.add("red");
      });
      sixteenClickCount = 1;
      speakNumber(10);
    } else if (sixteenClickCount === 1) {
      // Fill 6 purple dots in triangle pattern in top-right
      topRightIndices16.forEach(i => {
        const c = sixteenCircles[i];
        c.classList.remove(...COLOR_CLASSES);
        c.classList.add("purple");
      });
      sixteenClickCount = 2;
      speakNumber(16);
      // All dots are now filled (10 red + 6 purple = 16), show the answer
      answerDisplay16.textContent = '16';
      answerDisplay16.classList.add('show');
    } else {
      sixteenCircles.forEach(c => {
        c.classList.remove("red", "purple", ...COLOR_CLASSES);
      });
      sixteenClickCount = 0;
      answerDisplay16.textContent = '';
      answerDisplay16.classList.remove('show');
      speakNumber(0);
    }
  });
});

// Generate all squares from 5^2 to 25^2
function generateSquare(n) {
  const square = n * n;
  const gridSize = n;
  
  // Create section
  const section = document.createElement('section');
  section.className = 'set';
  section.dataset.square = square;
  section.dataset.base = n;
  
  const h2 = document.createElement('h2');
  h2.textContent = `${n}²`;
  section.appendChild(h2);
  
  const grid = document.createElement('div');
  grid.className = `grid-dynamic`;
  grid.id = `square-${square}`;
  grid.style.gridTemplateColumns = `repeat(${gridSize}, var(--circle-total))`;
  grid.style.gridTemplateRows = `repeat(${gridSize}, var(--circle-total))`;
  grid.style.width = `calc(var(--circle-total) * ${gridSize})`;
  grid.style.height = `calc(var(--circle-total) * ${gridSize})`;
  
  // For 256, 225, and 441, make grid position relative so we can absolutely position separated dots relative to it
  if (square === 256 || square === 225 || square === 441) {
    grid.style.position = 'relative';
  }
  
  // Create circles
  for (let i = 0; i < square; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle';
    grid.appendChild(circle);
  }
  
  section.appendChild(grid);
  
  // Add answer display
  const answerDisplay = document.createElement('div');
  answerDisplay.className = 'answer-display';
  answerDisplay.dataset.answer = square;
  section.appendChild(answerDisplay);
  
  // Setup click handlers
  const circles = Array.from(grid.querySelectorAll('.circle'));
  let clickCount = 0;
  // Track separated circles for 256 and 225
  const separatedCircles = [];
  const components = breakDownNumber(square);
  const totalClicks = components.length;
  
  // Get top right corner indices for ones place
  const onesValue = components[components.length - 1];
  let topRightIndices = [];
  
  // Special patterns for ones place - ALL ones place numbers go in top right corner
  // 6 dots: purple triangle pattern in top-right corner (for 16, 36, 196, 256, 576)
  // 9 dots: sky blue 3x3 square in top-right corner (for 49, 169, 289, 529)
  if (onesValue === 6) {
    // Triangle pattern for 6 (1, 2, 3 diagonal) - PURPLE
    topRightIndices = getTrianglePatternIndices(gridSize);
  } else if (onesValue === 4) {
    // 2x2 square for 4 (including 324)
    topRightIndices = get2x2TopRightIndices(gridSize);
  } else if (onesValue === 9) {
    // 3x3 square for 9 - SKY BLUE
    topRightIndices = get3x3TopRightIndices(gridSize);
  } else if (onesValue === 5) {
    // For 225: 5 blue dots in a vertical line in the rightmost column of the 5×5 rectangle (col 14, rows 0-4)
    // For 25: 5 blue dots in a vertical line in the rightmost column (col 4, rows 0-4)
    // For other squares: 2x2 square + 1 diagonal for 5
    if (square === 225) {
      // Vertical line: 5 dots in column 14 (rightmost column of the 5×5), rows 0-4
      topRightIndices = [];
      for (let row = 0; row < 5 && row < gridSize; row++) {
        topRightIndices.push(row * gridSize + 14);
      }
    } else if (square === 25) {
      // Vertical line: 5 dots in column 4 (rightmost column), rows 0-4
      topRightIndices = [];
      for (let row = 0; row < 5 && row < gridSize; row++) {
        topRightIndices.push(row * gridSize + 4);
      }
    } else {
      topRightIndices = get5DiagonalPatternIndices(gridSize);
    }
  } else if (onesValue === 1 && square === 441) {
    // For 441: 1 red dot at top right corner (row 0, col 20), will be offset
    topRightIndices = [0 * gridSize + 20];
  } else {
    // Default: top row rightmost positions
    topRightIndices = getTopRightCornerIndices(gridSize, onesValue);
  }
  
  // Helper to get bottom left indices (for hundreds place)
  function getBottomLeftIndices(gridSize, count) {
    const indices = [];
    // Start from bottom row, left side
    for (let row = gridSize - 1; row >= 0 && indices.length < count; row--) {
      for (let col = 0; col < gridSize && indices.length < count; col++) {
        const idx = row * gridSize + col;
        if (!topRightIndices.includes(idx)) {
          indices.push(idx);
        }
      }
    }
    return indices.slice(0, count);
  }
  
  // Helper to get upper left indices (for tens place when needed)
  function getUpperLeftIndices(gridSize, count) {
    const indices = [];
    // Start from top row, left side
    for (let row = 0; row < gridSize && indices.length < count; row++) {
      for (let col = 0; col < gridSize && indices.length < count; col++) {
        const idx = row * gridSize + col;
        if (!topRightIndices.includes(idx)) {
          indices.push(idx);
        }
      }
    }
    return indices.slice(0, count);
  }
  
  // Helper to get indices around ones place (for tens place separation in 3-digit numbers)
  function getIndicesAroundOnes(gridSize, count, topRightIndices, alreadyFilled) {
    const indices = [];
    const topRightSet = new Set(topRightIndices);
    const filledSet = new Set(alreadyFilled);
    
    // Get positions around the top right corner, working inward
    // Start from top rows, near the right side but not in ones place
    for (let row = 0; row < gridSize && indices.length < count; row++) {
      for (let col = gridSize - 1; col >= 0 && indices.length < count; col--) {
        const idx = row * gridSize + col;
        if (!topRightSet.has(idx) && !filledSet.has(idx)) {
          indices.push(idx);
        }
      }
    }
    return indices.slice(0, count);
  }
  
  // Helper to get upper left indices (for tens place in 2-digit numbers, or second component in 3-digit)
  function getUpperLeftIndices(gridSize, count, excludeIndices, alreadyFilled) {
    const indices = [];
    const excludeSet = new Set(excludeIndices || []);
    const filledSet = new Set(alreadyFilled || []);
    
    // Start from top row, left side
    for (let row = 0; row < gridSize && indices.length < count; row++) {
      for (let col = 0; col < gridSize && indices.length < count; col++) {
        const idx = row * gridSize + col;
        if (!excludeSet.has(idx) && !filledSet.has(idx)) {
          indices.push(idx);
        }
      }
    }
    return indices.slice(0, count);
  }
  
  // Make the entire grid clickable, not just individual circles
  grid.addEventListener("click", (e) => {
    // Ignore clicks on separated circles (they have data-originalRow attribute)
    if (e.target.dataset.originalRow !== undefined) {
      return;
    }
    
    // Check if we should reset (clicking after all components are filled)
    // For 441: clickCount will be 3 after 3 clicks (0, 1, 2), so 4th click should reset
    // Also check if answer is already showing (for numbers like 100 where we show answer early)
    const answerIsShowing = answerDisplay && answerDisplay.classList.contains('show');
    const nonZeroComponents = components.filter(c => c > 0);
    const processedNonZero = components.slice(0, clickCount).filter(c => c > 0).length;
    if (clickCount >= totalClicks || (answerIsShowing && processedNonZero >= nonZeroComponents.length)) {
      // Complete reset - go back to initial state (all black dots, nothing colored, nothing hidden)
      // For 441, be extra aggressive about removing the red dot
      if (square === 441) {
        // Remove ALL red circles first (most aggressive)
        const allRed = grid.querySelectorAll('.circle.red');
        allRed.forEach(rc => {
          // Remove if it's not in the original circles array (it's a separated circle)
          if (rc && rc.parentNode && !circles.includes(rc)) {
            rc.parentNode.removeChild(rc);
          }
        });
        
        // Remove all absolutely positioned circles (separated circles)
        const allAbsolute = Array.from(grid.children).filter(child => 
          child.style && child.style.position === 'absolute' && !circles.includes(child)
        );
        allAbsolute.forEach(ac => {
          if (ac && ac.parentNode) {
            ac.parentNode.removeChild(ac);
          }
        });
      }
      
      // Remove from the array
      separatedCircles.forEach(sc => {
        if (sc && sc.parentNode) {
          sc.parentNode.removeChild(sc);
        }
      });
      separatedCircles.length = 0;
      
      // Remove ALL separated circles by data attributes (these are the ones we created)
      const allSeparated = grid.querySelectorAll('[data-original-row][data-original-col]');
      allSeparated.forEach(sc => {
        // Only remove if it's NOT in the original circles array (it's a separated circle we created)
        if (sc && sc.parentNode && !circles.includes(sc)) {
          sc.parentNode.removeChild(sc);
        }
      });
      
      // Now completely reset ALL ORIGINAL circles to initial state
      circles.forEach(c => {
        // Remove all color classes INCLUDING "red" (red is not in COLOR_CLASSES array)
        c.classList.remove('red', ...COLOR_CLASSES);
        // Reset all styles to initial state
        c.style.visibility = '';
        c.style.display = '';
        c.style.position = '';
        c.style.zIndex = '';
        c.style.left = '';
        c.style.top = '';
        c.style.opacity = '';
      });
      
      // Aggressive check for ALL squares: remove ANY remaining red circles that are children of grid
      // This ensures no red dots are left behind (like for 81, 100, 441, etc.)
      const allGridChildren = Array.from(grid.children);
      allGridChildren.forEach(child => {
        if (child.classList && child.classList.contains('red') && !circles.includes(child)) {
          if (child && child.parentNode) {
            child.parentNode.removeChild(child);
          }
        }
        // Also remove red class from any circles that might still have it
        if (child.classList && child.classList.contains('red') && circles.includes(child)) {
          child.classList.remove('red');
        }
      });
      
      // Extra check for 441: explicitly ensure row 0, col 20 is black and visible
      if (square === 441) {
        const idx = 0 * gridSize + 20;
        if (circles[idx]) {
          // Force remove red class
          circles[idx].classList.remove('red', ...COLOR_CLASSES);
          circles[idx].style.visibility = '';
          circles[idx].style.display = '';
          circles[idx].style.position = '';
          circles[idx].style.zIndex = '';
          circles[idx].style.left = '';
          circles[idx].style.top = '';
          circles[idx].style.opacity = '';
        }
      }
      
      // Extra check for 81 (9×9): ensure all red dots are removed
      if (square === 81) {
        circles.forEach(c => {
          c.classList.remove('red', ...COLOR_CLASSES);
        });
      }
      
      // Extra check for 100 (10×10): ensure all red dots are removed
      if (square === 100) {
        circles.forEach(c => {
          c.classList.remove('red', ...COLOR_CLASSES);
        });
      }
      
      // Reset click count and display
      clickCount = 0;
      answerDisplay.textContent = '';
      answerDisplay.classList.remove('show');
      speakNumber(0);
      return;
    }
    
    // Process clicks on the grid itself or on regular circles
    if (clickCount < totalClicks) {
        const componentValue = components[clickCount];
        const isOnesPlace = (clickCount === totalClicks - 1);
        const isHundredsPlace = (clickCount === 0 && components.length === 3);
        const isTensPlace = (clickCount === 1 && components.length === 3) || (clickCount === 0 && components.length === 2);
        
        // If component value is 0, skip filling but still increment clickCount
        if (componentValue === 0) {
          clickCount++;
          const currentTotal = components.slice(0, clickCount).reduce((a, b) => a + b, 0);
          speakNumber(currentTotal);
          
          // Show answer when all components are processed
          // For numbers like 100 where components are [100, 0, 0], show answer after processing non-zero components
          const nonZeroComponents = components.filter(c => c > 0);
          const processedNonZero = components.slice(0, clickCount).filter(c => c > 0).length;
          if ((clickCount >= totalClicks || processedNonZero >= nonZeroComponents.length) && answerDisplay) {
            answerDisplay.textContent = square;
            answerDisplay.classList.add('show');
          }
          return; // Exit early, don't try to fill 0 dots
        }
        
        // Get color based on first digit of component
        const componentStr = componentValue.toString();
        const firstDigit = parseInt(componentStr[0]);
        const colorKey = firstDigit || 10;
        const color = COLOR_MAP[colorKey] || "red";
        
        // Track already filled indices (check for any color class)
        const alreadyFilled = new Set();
        circles.forEach((c, i) => {
          if (c.classList.contains("red") || c.classList.contains("orange") || 
              c.classList.contains("yellow") || c.classList.contains("green") ||
              c.classList.contains("blue") || c.classList.contains("purple") ||
              c.classList.contains("brown") || c.classList.contains("pink") ||
              c.classList.contains("sky") || c.classList.contains("red-final")) {
            alreadyFilled.add(i);
          }
        });
        
        let indicesToFill = [];
        
        if (isOnesPlace) {
          // Ones place: use the pre-calculated top right indices
          indicesToFill = topRightIndices.filter(i => !alreadyFilled.has(i));
        } else if (isHundredsPlace) {
          // Hundreds place: start from bottom left, fill all the way to top
          if (square === 144) {
            // Special: 144 - fill 100 red, but leave space for 40 green (rows 2-5, left 10 cols) and 4 (top right 2x2)
            const allIndices = [];
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip top right 2x2 (for 4) and rows 2-5, left 10 cols (for 40 green)
                if (!topRightIndices.includes(idx) && 
                    !(row >= 2 && row < 6 && col < 10)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 169) {
            // Special: 169 - 100 red at bottom, leave space for 60 purple and 9 sky
            const allIndices = [];
            // Fill from bottom, leave top 3 rows for 60 purple and 9 sky
            // Fill bottom rows first
            for (let row = gridSize - 1; row >= 3 && allIndices.length < componentValue; row--) {
              for (let col = 0; col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Fill remaining from row 3, avoiding the top right 3x3 area
            for (let col = 0; col < gridSize - 3 && allIndices.length < componentValue; col++) {
              const idx = 3 * gridSize + col;
              if (!topRightIndices.includes(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 361) {
            // Special: 361 - 300 yellow, leave space for 60 purple + 1 red
            // Pattern exactly as specified:
            // Row 0: 1 yellow + 7 purple + 1 red
            // Row 1: 1 yellow + 8 purple
            // Rows 2-5: 8 purple each
            // Row 6: 7 purple
            // Row 7: 6 purple
            // Total: 60 purple + 1 red = 61 positions
            // Pattern: Row 0: col 10 (yellow) + cols 11-17 (7 purple) + col 18 (red)
            // Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            // Rows 2-5: cols 11-18 (8 purple each)
            // Row 6: cols 12-18 (7 purple)
            // Row 7: cols 13-18 (6 purple)
            const allIndices = [];
            // Fill from bottom, leaving the specified areas empty
            // Note: col 10 in rows 0-1 should be filled with yellow (not skipped)
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip row 0: cols 11-18 (7 purple + 1 red), but fill col 10 (yellow)
                if (row === 0 && col >= 11 && col <= 18) {
                  continue;
                }
                // Skip row 1: cols 11-18 (8 purple), but fill col 10 (yellow)
                if (row === 1 && col >= 11 && col <= 18) {
                  continue;
                }
                // Skip rows 2-5: cols 11-18 (8 purple each)
                if (row >= 2 && row <= 5 && col >= 11 && col <= 18) {
                  continue;
                }
                // Skip row 6: cols 12-18 (7 purple)
                if (row === 6 && col >= 12 && col <= 18) {
                  continue;
                }
                // Skip row 7: cols 13-18 (6 purple)
                if (row === 7 && col >= 13 && col <= 18) {
                  continue;
                }
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 441) {
            // Special: 441 - 400 green, need to leave space for 41 (8×5 rectangle + 1 diagonal dot)
            // Row 0, col 12 (13th dot in top row) should be green on first click
            // Row 0, col 20 (top-right corner) should remain BLACK until third click (when it becomes red)
            // Row 5, col 12 (diagonal dot from bottom-left of rectangle) should remain black until second click
            const allIndices = [];
            // Fill from bottom, but skip:
            // - The entire 8×5 rectangle on the right (rows 0-4, cols 13-20)
            // - Row 4, col 12 (diagonal dot that will be part of the 41)
            // BUT: Include row 0, col 12 (13th dot in top row) - it should be green
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the entire 8×5 rectangle area (rows 0-4, cols 13-20)
                if (row >= 0 && row < 5 && col >= 13 && col < 21) {
                  continue;
                }
                // Skip row 5, col 12 (diagonal dot that will be part of the 41 on second click)
                if (row === 5 && col === 12) {
                  continue;
                }
                // Include row 0, col 12 (13th dot in top row) - it should be green
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 225) {
            // Special: 225 - 200 orange, leave exactly 25 black dots in a 5×5 rectangle (rows 0-4, cols 10-14)
            const allIndices = [];
            // Fill from bottom, leaving exactly the 5×5 rectangle (rows 0-4, cols 10-14) empty
            // Fill all rows from bottom up, skipping only the 5×5 area
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip the 5×5 rectangle area (rows 0-4, cols 10-14)
                if (row < 5 && col >= 10 && col <= 14) {
                  continue; // Skip this position - it's in the 5×5 area
                }
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 289) {
            // Special: 289 - 200 orange, leave clean top-right area for 80 pink + 9 sky blue (89 total)
            // We need exactly 89 positions empty (289 - 200 = 89)
            // Leave: rows 0-8, cols 8-16 (9 rows × 9 cols = 81) + row 9, cols 9-16 (1 row × 8 cols = 8) = 89 positions
            // This ensures a clean top-right corner with no orange dots
            const allIndices = [];
            // Fill from bottom, leaving the top-right area empty
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip rows 0-8, cols 8-16 (9 rows × 9 cols = 81 positions)
                if (row >= 0 && row <= 8 && col >= 8 && col <= 16) {
                  continue;
                }
                // Skip row 9, cols 9-16 (1 row × 8 cols = 8 positions)
                if (row === 9 && col >= 9 && col <= 16) {
                  continue;
                }
                // Total skipped: 81 + 8 = 89 positions, leaving exactly 200 available for orange
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 324) {
            // Special: 324 - 300 yellow, leave space for 20 orange + 4 green
            // Pattern: 4 rows (rows 0-3) × 5 columns (cols 13-17) + 1 row (row 4) × 4 columns (cols 14-17)
            // The 4 green are in a 2x2 square at rows 0-1, cols 16-17
            // Top part: 4 rows × 5 cols = 20 positions, minus 4 green = 16 orange
            // Bottom row: 1 row × 4 cols (cols 14-17) = 4 orange (moved 2 positions to the right)
            // Total = 20 orange
            const allIndices = [];
            // Fill from bottom, leaving:
            // - rows 0-3, cols 13-17 (for 16 orange + 4 green in top part)
            // - row 4, cols 14-17 (for 4 orange in bottom row, moved 2 positions right)
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip rows 0-3, cols 13-17 (the top part for orange + green)
                if (row >= 0 && row <= 3 && col >= 13 && col <= 17) {
                  continue;
                }
                // Skip row 4, cols 14-17 (the bottom row for orange, moved 2 positions right)
                if (row === 4 && col >= 14 && col <= 17) {
                  continue;
                }
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 484) {
            // Special: 484 - 400 green, leave space for 9×9 rectangle
            // The 9×9 rectangle: rows 0-8, cols 13-21 (top-right corner area)
            // Pattern: rows 0-7 have 5 green on left (cols 13-17) + 4 pink on right (cols 18-21)
            // Row 8 (bottom row) has all 9 green (cols 13-21)
            // The 2×2 square (4 green) is at rows 0-1, cols 20-21 (top-right of 9×9)
            const nineByNineIndices = [];
            for (let row = 0; row < 9; row++) {
              for (let col = 13; col < 22; col++) {
                nineByNineIndices.push(row * gridSize + col);
              }
            }
            // The green dots in the 9×9 that are part of 400 green:
            // - Rows 0-7: cols 13-17 (5 green per row) = 8×5 = 40 green
            // - Row 8: cols 13-21 (all 9 green) = 9 green
            // Total green in 9×9: 40 + 9 = 49 green (but 4 of these will be changed to green on third click for the 2×2)
            // Actually, the 2×2 (rows 0-1, cols 20-21) overlaps with the green area
            // So: rows 0-7 cols 13-17 (40 green) + row 8 cols 13-21 (9 green) = 49 green
            // But rows 0-1 cols 20-21 (4 dots) are in the pink area, so they'll be pink on second click, then green on third
            const greenInNineByNine = [];
            // Rows 0-7: cols 13-17 (5 green per row)
            for (let row = 0; row < 8; row++) {
              for (let col = 13; col < 18; col++) {
                greenInNineByNine.push(row * gridSize + col);
              }
            }
            // Row 8: cols 13-21 (all 9 green)
            for (let col = 13; col < 22; col++) {
              greenInNineByNine.push(8 * gridSize + col);
            }
            const allIndices = [];
            // Fill from bottom, leaving space for the 9×9 rectangle EXCEPT the green parts (which we fill as part of 400 green)
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the 2×2 square (top-right) - will be filled on third click
                if (topRightIndices.includes(idx)) {
                  continue;
                }
                // Skip the 9×9 rectangle EXCEPT the green parts (which we include in 400 green)
                if (nineByNineIndices.includes(idx) && !greenInNineByNine.includes(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 529) {
            // Special: 529 - 500 blue, leave space for 20 orange (4×5 rectangle) and 9 (top right 3x3)
            // The 20 orange rectangle: rows 0-3, cols 15-19 (4 rows × 5 cols = 20)
            // The 9 sky blue: rows 0-2, cols 20-22 (3×3 in top-right)
            const orangeRectangleIndices = [];
            for (let row = 0; row < 4; row++) {
              for (let col = 15; col < 20; col++) {
                orangeRectangleIndices.push(row * gridSize + col);
              }
            }
            const allIndices = [];
            // Fill from bottom, leaving space for 20 orange rectangle and 3×3 square
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the 3×3 square (top-right)
                if (topRightIndices.includes(idx)) {
                  continue;
                }
                // Skip the 20 orange rectangle (rows 0-3, cols 15-19)
                if (orangeRectangleIndices.includes(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 625) {
            // Special: 625 - 600 yellow, leave space for 20 orange and 5 (top right 2x2+1)
            const allIndices = [];
            // Fill from bottom, leave space for 20 orange and top right 5-dot pattern
            for (let row = gridSize - 1; row >= 2; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Fill row 2, but skip top right 5-dot pattern area (2x2 + diagonal)
            for (let col = 0; col < gridSize - 3 && allIndices.length < componentValue; col++) {
              const idx = 2 * gridSize + col;
              if (!topRightIndices.includes(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else {
            // Default: start from bottom left
            const allIndices = getBottomLeftIndices(gridSize, componentValue + onesValue);
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i) && !topRightIndices.includes(i))
              .slice(0, componentValue);
          }
        } else if (isTensPlace && components.length === 3) {
          // Tens place in 3-digit number
          if (square === 144) {
            // Special: 144 - 40 green as 4 rows of 10, in rows 2-5
            // Place in rows 2-5, left 10 columns
            const allIndices = [];
            // Fill 4 rows of 10, starting at row 2
            for (let row = 2; row < 6 && row < gridSize; row++) {
              for (let col = 0; col < 10 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 169) {
            // Special: 169 - 60 purple to the left of the 9, fill all 60
            const allIndices = [];
            // Fill area to the left of top right 3x3, and below
            // Start from top rows, left side
            for (let row = 0; row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 0; col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 225) {
            // Special: 225 - 20 orange in a 5×5 rectangle (5 columns × 5 rows)
            // Fill only the first 4 columns (cols 10-13) × 5 rows (rows 0-4) = 20 orange dots
            // Leave the rightmost column (col 14) black for now (will turn blue on 3rd click)
            // Position: rows 0-4, cols 10-13 (4 columns × 5 rows = 20 dots)
            // These stay attached in the grid, NOT separated like the 6 purple dots
            const allIndices = [];
            // Create 5 rows of 4 dots each (4 columns × 5 rows = 20 dots)
            // Only fill cols 10-13, leaving col 14 black (will be blue on 3rd click)
            for (let row = 0; row < 5 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 10; col < 14 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                // Don't include topRightIndices (the 5 blue dots in col 14) or already filled
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 289) {
            // Special: 289 - 80 pink, fill the top-right area we left empty, excluding the 9 sky blue (3×3)
            // The area we left empty: rows 0-8, cols 8-16 (81 positions) + row 9, cols 9-16 (8 positions) = 89 positions
            // The 9 sky blue dots are in rows 0-2, cols 14-16 (3×3 in top-right)
            // Fill 89 - 9 = 80 pink dots in the top-right area
            const allIndices = [];
            // Fill rows 0-8, cols 8-16 (excluding the 9 cyan in rows 0-2, cols 14-16)
            for (let row = 0; row < 9 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 8; col < 17 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                // Exclude the 9 sky blue dots (rows 0-2, cols 14-16) and already filled dots
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Fill row 9, cols 9-16 (excluding any overlaps)
            for (let col = 9; col < 17 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 9 * gridSize + col;
              // Exclude already filled dots
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 324) {
            // Special: 324 - 20 orange in pattern: 4 rows × 5 cols (top) + 1 row × 4 cols (bottom)
            // The 4 green are in a 2x2 square at rows 0-1, cols 16-17 (top-right corner)
            // Top part: 4 rows (rows 0-3) × 5 columns (cols 13-17) = 20 positions, minus 4 green = 16 orange
            // Bottom row: 1 row (row 4) × 4 columns (cols 14-17) = 4 orange (moved 2 positions to the right)
            // Total = 20 orange
            const allIndices = [];
            // Fill top part: rows 0-3, cols 13-17 (excluding the 2x2 green)
            for (let row = 0; row < 4 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 13; col < 18 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                // Exclude the 4 green dots (2x2 at rows 0-1, cols 16-17) and already filled dots
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Fill bottom row: row 4, cols 14-17 (moved 2 positions to the right)
            for (let col = 14; col < 18 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 4 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 361) {
            // Special: 361 - 60 purple exactly as specified:
            // Row 0: 1 yellow (col 11) + 7 purple (cols 12-18, but red is at col 18, so cols 12-17 = 6 purple, col 18 = red)
            // Actually: Row 0 has 7 purple + 1 red, so if red is at col 18, then cols 12-17 = 6 purple... 
            // Let me interpret: Row 0 has 7 purple dots in the purple section, plus 1 red = 8 total in that section
            // Row 1: 1 yellow (col 11) + 8 purple (cols 12-18, but only 7 columns, so maybe cols 11-18 with yellow at 11?)
            // Actually, re-reading: "the first as yellow and then it has 7 purple dot and one red dot"
            // So row 0: yellow + 7 purple + 1 red
            // If red is at col 18, and we have 7 purple before it: cols 11-17 = 1 yellow + 7 purple, col 18 = red
            // Row 1: yellow + 8 purple = cols 11 (yellow) + cols 12-18 (7 purple, but they said 8...)
            // Maybe: Row 1: col 11 (yellow) + cols 12-19 (8 purple) but col 19 doesn't exist in 19×19
            // Let me assume: Row 0: col 11 (yellow) + cols 12-18 (7 purple + 1 red at 18)
            // Row 1: col 11 (yellow) + cols 12-18 (8 purple, but only 7 columns available)
            // I think the pattern might be: Row 0: col 11 (yellow) + cols 12-18 (7 purple + 1 red)
            // Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            // Rows 2-5: cols 11-18 (8 purple each)
            // Row 6: cols 12-18 (7 purple)
            // Row 7: cols 13-18 (6 purple)
            // Let me implement based on the description more literally
            const allIndices = [];
            // Row 0: 1 yellow (col 11) + 7 purple (cols 12-17) + 1 red (col 18) - red excluded here
            // Row 1: 1 yellow (col 11) + 8 purple (cols 12-18, but only 7 available, so cols 12-18)
            // Actually, let me count: if row 1 has 8 purple and we start at col 12, we need cols 12-19, but only have 12-18
            // So maybe: Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            // Row 0: col 11 (yellow) + cols 12-17 (6 purple) + col 18 (red) = but that's 6 purple, not 7
            // Let me try: Row 0: col 11 (yellow) + cols 12-18 (7 positions: 6 purple + 1 red)
            // But they said 7 purple, so maybe: Row 0: col 10 (yellow) + cols 11-17 (7 purple) + col 18 (red)
            // Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            // Rows 2-5: cols 11-18 (8 purple each)
            // Row 6: cols 12-18 (7 purple)
            // Row 7: cols 13-18 (6 purple)
            // Let me implement this pattern
            // Row 0: col 10 (yellow) + cols 11-17 (7 purple) + col 18 (red, excluded)
            for (let col = 11; col < 18 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 0 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            // Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            for (let col = 11; col < 19 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 1 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            // Rows 2-5: cols 11-18 (8 purple each)
            for (let row = 2; row < 6 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 11; col < 19 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Row 6: cols 12-18 (7 purple)
            for (let col = 12; col < 19 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 6 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            // Row 7: cols 13-18 (6 purple)
            for (let col = 13; col < 19 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 7 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 441) {
            // Special: 441 - 41 dots total: 40 in 8×5 rectangle + 1 diagonal dot
            // All 41 should offset together on second click
            // BUT: row 0, col 20 (top-right of rectangle) stays BLACK until third click
            const allIndices = [];
            // 8×5 rectangle: rows 0-4, cols 13-20 (40 positions total)
            // Fill 39 positions in the rectangle (excluding row 0, col 20 which stays black)
            for (let row = 0; row < 5 && row < gridSize; row++) {
              for (let col = 13; col < 21 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Exclude row 0, col 20 - it stays black until third click
                if (row === 0 && col === 20) {
                  continue;
                }
                // Include the other 39 positions in the rectangle
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Add the diagonal dot (row 5, col 12) - diagonal from bottom-left of rectangle (row 4, col 13)
            // This makes 40 dots total (39 in rectangle + 1 diagonal)
            const diagonalIdx = 5 * gridSize + 12;
            // Ensure diagonal dot is included - add it at the end to guarantee it's in the 40
            if (!alreadyFilled.has(diagonalIdx) && !allIndices.includes(diagonalIdx)) {
              allIndices.push(diagonalIdx);
            }
            // We need 41 dots total, but row 0, col 20 stays black
            // So we fill 40 dots here (39 in rectangle + 1 diagonal)
            // The 41st dot (row 0, col 20) will be filled on the third click as red
            // Make sure we get exactly 40 dots (componentValue is 40)
            // Ensure diagonal dot is always included in the final list
            indicesToFill = allIndices.slice(0, componentValue);
            if (!indicesToFill.includes(diagonalIdx) && allIndices.includes(diagonalIdx)) {
              // Replace the last item with diagonal dot to ensure it's included
              indicesToFill[indicesToFill.length - 1] = diagonalIdx;
            }
          } else if (square === 484) {
            // Special: 484 - 80 pink in a 9×9 rectangle (rows 0-8, cols 13-21)
            // Pattern: rows 0-7 have 4 pink on right (cols 18-21) = 8×4 = 32 pink
            // But we need 80 pink total, so we need more
            // Actually, looking at the pattern: rows 0-7 have 5 green + 4 pink, row 8 has all green
            // So pink area: rows 0-7, cols 18-21 = 8×4 = 32 pink
            // But we need 80 pink, so maybe the pattern is different
            // Let me recalculate: 9×9 = 81 total
            // Green in 9×9: rows 0-7 cols 13-17 (40) + row 8 cols 13-21 (9) = 49 green
            // Pink in 9×9: 81 - 49 = 32 pink (but we need 80!)
            // Wait, maybe the pattern extends beyond the 9×9? Or maybe I misunderstood
            // Let me try: rows 0-7 have 4 pink (cols 18-21), that's 32 pink
            // To get 80 pink, we need 80 - 32 = 48 more pink
            // Maybe rows 0-7 also have pink in cols 13-17? But those are green...
            // Actually, I think the user wants: fill rows 0-7 cols 18-21 (32 pink) + fill more to get 80 total
            // But the image shows rows 0-7 have 4 pink on right, row 8 all green
            // So maybe: fill rows 0-7 cols 18-21 (32 pink) + fill additional positions to reach 80
            // Actually, let me fill the pink area as shown: rows 0-7, cols 18-21 (but exclude 2×2)
            const allIndices = [];
            // Fill rows 0-7: cols 18-21 (4 pink per row) = 8×4 = 32 pink
            // But we need 80 pink, so fill more positions
            // Fill all positions in 9×9 that are not green and not the 2×2
            for (let row = 0; row < 9 && row < gridSize; row++) {
              for (let col = 13; col < 22 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Exclude the 2×2 square (rows 0-1, cols 20-21) - these will be green on third click
                if (topRightIndices.includes(idx)) {
                  continue;
                }
                // Exclude green areas (rows 0-7 cols 13-17, row 8 cols 13-21) - already filled as green
                const isGreenArea = (row < 8 && col >= 13 && col < 18) || (row === 8 && col >= 13 && col < 22);
                if (isGreenArea) {
                  continue;
                }
                // Fill pink area: rows 0-7, cols 18-21 (but this is only 32 pink)
                // To get 80 pink, we need to fill more - maybe extend the pattern?
                // Actually, let me fill rows 0-7 cols 18-21 first, then fill additional positions
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // We need exactly 80 pink dots, but the pattern only gives us 32
            // Maybe the user wants us to fill beyond the 9×9? Or fill differently?
            // For now, fill what we can in the pink area
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 529) {
            // Special: 529 - 20 orange in a 4×5 rectangle (rows 0-3, cols 15-19)
            const allIndices = [];
            // Fill exactly the 4×5 rectangle: rows 0-3, cols 15-19
            for (let row = 0; row < 4 && row < gridSize; row++) {
              for (let col = 15; col < 20 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 625) {
            // Special: 625 - 20 orange, fill all 20 dots
            const allIndices = [];
            // Fill all available spaces except top right 5-dot pattern
            for (let row = 0; row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 0; col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else {
            // Other 3-digit: around/separating the ones place
            indicesToFill = getIndicesAroundOnes(gridSize, componentValue, topRightIndices, alreadyFilled);
          }
        } else if (isTensPlace && components.length === 2) {
          // Tens place in 2-digit number: upper left area (for 49, this is the 40)
          if (square === 25) {
            // Special: 25 - 20 orange in first 4 columns (cols 0-3, rows 0-4), leaving 5 black (col 4, rows 0-4)
            const allIndices = [];
            // Fill 4 columns × 5 rows = 20 orange dots (cols 0-3, rows 0-4)
            // Leave col 4 (rightmost column) for 5 blue dots
            for (let row = 0; row < 5 && row < gridSize; row++) {
              for (let col = 0; col < 4 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 36) {
            // Special: 36 - 30 yellow, fill all 30 dots, leaving space for 6 (top right triangle)
            const allIndices = [];
            // Fill all available spaces except top right triangle pattern
            // Collect all indices first, then slice
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 49) {
            // Special: 49 - 40 orange, fill all 40 dots, leaving space for 9 (top right 3x3)
            const allIndices = [];
            // Fill all available spaces except top right 3x3
            // Collect all indices first, then slice
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else {
            indicesToFill = getUpperLeftIndices(gridSize, componentValue, topRightIndices, alreadyFilled);
          }
        } else {
          // Fallback: fill remaining empty spaces
          for (let i = 0; i < circles.length && indicesToFill.length < componentValue; i++) {
            if (!alreadyFilled.has(i) && !topRightIndices.includes(i)) {
              indicesToFill.push(i);
            }
          }
        }
        
        // Fill the indices (only fill as many as needed)
        const filledCount = { count: 0 };
        // For 441, we need to fill 40 dots on second click (39 in rectangle + 1 diagonal)
        // Make sure we process all indices, not just up to componentValue
        const indicesToProcess = (square === 441 && isTensPlace) ? indicesToFill : indicesToFill.slice(0, componentValue);
        indicesToProcess.forEach(i => {
          const c = circles[i];
          // Only fill if not already filled
          if (!alreadyFilled.has(i)) {
            c.classList.remove(...COLOR_CLASSES);
            c.classList.add(color);
            filledCount.count++;
            
            // For 441, offset ALL 41 dots (tens place) - the entire 8×5 rectangle + 1 diagonal dot
            // All 41 dots should offset together on the second click
            // This includes row 0, col 20 which stays black but also offsets
            if (square === 441 && isTensPlace) {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Check if this dot is part of the 41 that should offset:
              // - All dots in the 8×5 rectangle (rows 0-4, cols 13-20) - including row 0, col 20
              // - The diagonal dot (row 5, col 12) - diagonal from bottom-left of rectangle (row 4, col 13)
              const isInRectangle = (row >= 0 && row < 5 && col >= 13 && col < 21);
              const isDiagonalDot = (row === 5 && col === 12);
              
              if (isInRectangle || isDiagonalDot) {
                // Hide the original circle in the grid
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (!existingSeparated) {
                  // Create a new circle positioned offset (all 41 move together)
                  // For row 0, col 20, keep it black (don't add color class)
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = 'circle'; // Start with no color (black)
                  // If this is not row 0, col 20, add the green color
                  if (!(row === 0 && col === 20)) {
                    separatedCircle.className = `circle ${color}`;
                  }
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '5';
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  
                  // Special handling for diagonal dot (row 5, col 12) - needs to touch rectangle's bottom-left tangentially
                  if (isDiagonalDot) {
                    // The rectangle's bottom-left is at row 4, col 13
                    // After standard offset, it's at: (col 13 + 1.2) * circle-total, (row 4 - 1.2) * circle-total
                    // The diagonal dot is at row 5, col 12 (one row down, one col left from rectangle's bottom-left)
                    // To touch the rectangle's bottom-left tangentially after offset, move it just a bit closer:
                    // - Move it slightly more to the right: col 12 + 1.2 + 0.3 = col 12 + 1.5 (just touching)
                    // - Move it slightly more up: row 5 - 1.2 - 0.3 = row 5 - 1.5 (just touching)
                    separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 1.5 * var(--circle-total))`;
                    separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 1.5 * var(--circle-total))`;
                    // Ensure it's visible and has green color, and give it a higher z-index so it's on top
                    separatedCircle.className = `circle ${color}`;
                    separatedCircle.style.zIndex = '6'; // Slightly higher than rectangle dots to ensure visibility
                  } else {
                    // Standard offset for all other dots (all 41 move together)
                    separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 1.2 * var(--circle-total))`;
                    separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 1.2 * var(--circle-total))`;
                  }
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                }
              }
            }
            
            // For 441, offset the 1 part (ones place) - red dot at top right corner, offset
            if (square === 441 && isOnesPlace) {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Only process the single dot at top right corner (row 0, col 20)
              if (row === 0 && col === 20) {
                // Hide the original circle in the grid
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index (the black one from second click)
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (existingSeparated) {
                  // Update the existing black separated circle to red
                  existingSeparated.classList.remove(...COLOR_CLASSES);
                  existingSeparated.classList.add(color); // Add red color
                  existingSeparated.style.zIndex = '10'; // Higher z-index for red dot
                  // Move it just a little bit more (smaller offset) so it's slightly separated
                  existingSeparated.style.left = `calc(var(--circle-total) * ${col} + 1.2 * var(--circle-total) + 0.3 * var(--circle-total))`;
                  existingSeparated.style.top = `calc(var(--circle-total) * ${row} - 1.2 * var(--circle-total) - 0.3 * var(--circle-total))`;
                } else {
                  // Create a new circle positioned offset (right and up from top-right corner)
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = `circle ${color}`;
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '10';
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  // Small offset to the right and up (the red dot moves just a little bit)
                  separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 1.2 * var(--circle-total) + 0.3 * var(--circle-total))`;
                  separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 1.2 * var(--circle-total) - 0.3 * var(--circle-total))`;
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                }
              }
            }
            
            // For 225, make sure blue dots (ones place) appear on top
            if (square === 225 && isOnesPlace && color === 'blue') {
              c.style.zIndex = '20';
              c.style.position = 'relative';
            }
            
            // For 256, separate the 6 purple dots from the main grid
            if (square === 256 && isOnesPlace && color === 'purple') {
              // Hide the original circle in the grid (remove it from the visual grid)
              c.style.visibility = 'hidden';
              
              // Check if we've already created a separated circle for this index
              const existingSeparated = separatedCircles.find(sc => {
                const scRow = parseInt(sc.dataset.originalRow);
                const scCol = parseInt(sc.dataset.originalCol);
                return scRow === Math.floor(i / gridSize) && scCol === (i % gridSize);
              });
              
              if (!existingSeparated) {
                // Create a new circle positioned to the right and up, separated from the main grid
                const separatedCircle = document.createElement('div');
                separatedCircle.className = 'circle purple';
                separatedCircle.style.position = 'absolute';
                separatedCircle.style.zIndex = '10';
                const row = Math.floor(i / gridSize);
                const col = i % gridSize;
                separatedCircle.dataset.originalRow = row;
                separatedCircle.dataset.originalCol = col;
                // Position to the right and up from where the original circle was in the top-right corner
                // Move right: original column position + small gap (1.2 circle widths) for subtle separation
                // Move up: original row position - small offset (0.3 circle height) for subtle separation
                separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 1.2 * var(--circle-total))`;
                separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 0.3 * var(--circle-total))`;
                separatedCircle.style.display = 'block';
                separatedCircle.style.visibility = 'visible';
                separatedCircle.style.opacity = '1';
                grid.appendChild(separatedCircle);
                separatedCircles.push(separatedCircle);
              }
            }
            
            // For 225, separate the entire 5×5 rectangle (20 orange + 5 black) from the main grid
            // On second click: 20 orange dots (cols 10-13, rows 0-4) are separated and filled
            // Also create the 5 black dots in the separated position (col 14, rows 0-4)
            if (square === 225 && isTensPlace && color === 'orange') {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Only process dots that are in the 5×5 area (rows 0-4, cols 10-14)
              if (row >= 0 && row < 5 && col >= 10 && col <= 14) {
                // Hide the original circle in the grid (remove it from the visual grid)
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (!existingSeparated) {
                  // Create a new circle positioned to the right and up, separated from the main grid
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = 'circle orange';
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '5'; // Lower z-index than blue dots
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  // Position to the right and up from where the original circle was
                  // Symmetric offset: same distance right and up for balanced separation
                  separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 0.5 * var(--circle-total))`;
                  separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 0.5 * var(--circle-total))`;
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                }
              }
            }
            
            // For 225, also separate the 5 blue dots (ones place) in the separated 5×5 rectangle
            // The blue dots should replace the 5 black separated dots in col 14 (rightmost column)
            if (square === 225 && isOnesPlace && color === 'blue') {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Only process dots that are in the rightmost column (col 14) of the 5×5 area (rows 0-4)
              if (row >= 0 && row < 5 && col === 14) {
                // Hide the original circle in the grid (remove it from the visual grid)
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index (should be a black one from second click)
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (existingSeparated) {
                  // If already existing (the black separated dot from second click), just update its color and z-index
                  existingSeparated.classList.remove(...COLOR_CLASSES);
                  existingSeparated.classList.add('blue');
                  existingSeparated.style.zIndex = '20'; // Higher z-index to appear on top
                } else {
                  // Should not happen, but create it if somehow missing
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = 'circle blue';
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '20'; // Higher z-index to appear on top
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  // Position to the right and up from where the original circle was
                  // Same offset as the orange dots so they form the complete 5×5 rectangle
                  separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 0.5 * var(--circle-total))`;
                  separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 0.5 * var(--circle-total))`;
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                }
              }
            }
          }
        });
        
        // For 441, after filling the 40 dots on second click, also offset row 0, col 20 (stays black)
        // Note: clickCount is 1 on second click (0-indexed: 0=first, 1=second, 2=third)
        if (square === 441 && isTensPlace) {
          const row = 0;
          const col = 20;
          const idx = row * gridSize + col;
          
          // Check if we need to offset row 0, col 20 (even though it's not being filled green)
          const existingSeparated = separatedCircles.find(sc => {
            const scRow = parseInt(sc.dataset.originalRow);
            const scCol = parseInt(sc.dataset.originalCol);
            return scRow === row && scCol === col;
          });
          
          if (!existingSeparated) {
            // Hide the original circle in the grid
            const c = circles[idx];
            if (c) {
              c.style.visibility = 'hidden';
              
              // Create a new circle positioned offset but keep it black
              const separatedCircle = document.createElement('div');
              separatedCircle.className = 'circle'; // Black (no color class)
              separatedCircle.style.position = 'absolute';
              separatedCircle.style.zIndex = '5';
              separatedCircle.dataset.originalRow = row;
              separatedCircle.dataset.originalCol = col;
              // Offset to the right and up (moves with the other 40)
              separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 1.2 * var(--circle-total))`;
              separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 1.2 * var(--circle-total))`;
              separatedCircle.style.display = 'block';
              separatedCircle.style.visibility = 'visible';
              separatedCircle.style.opacity = '1';
              grid.appendChild(separatedCircle);
              separatedCircles.push(separatedCircle);
            }
          }
        }
        
        // For 225, after filling all 20 orange dots on second click, hide the original 5 black dots and create them in separated position
        if (square === 225 && isTensPlace && filledCount.count === componentValue) {
          // All 20 orange dots filled, now hide the original 5 black dots and create them in separated position
          for (let blackRow = 0; blackRow < 5; blackRow++) {
            const blackCol = 14; // Rightmost column of the 5×5
            const blackIdx = blackRow * gridSize + blackCol;
            
            // Hide the original black circle in the grid
            if (circles[blackIdx]) {
              circles[blackIdx].style.visibility = 'hidden';
            }
            
            // Check if we've already created this separated black circle
            const existingBlack = separatedCircles.find(sc => {
              return parseInt(sc.dataset.originalRow) === blackRow && parseInt(sc.dataset.originalCol) === blackCol;
            });
            
            if (!existingBlack) {
              const separatedBlackCircle = document.createElement('div');
              separatedBlackCircle.className = 'circle'; // Black (no color class)
              separatedBlackCircle.style.position = 'absolute';
              separatedBlackCircle.style.zIndex = '5';
              separatedBlackCircle.dataset.originalRow = blackRow;
              separatedBlackCircle.dataset.originalCol = blackCol;
              separatedBlackCircle.style.left = `calc(var(--circle-total) * ${blackCol} + 0.5 * var(--circle-total))`;
              separatedBlackCircle.style.top = `calc(var(--circle-total) * ${blackRow} - 0.5 * var(--circle-total))`;
              separatedBlackCircle.style.display = 'block';
              separatedBlackCircle.style.visibility = 'visible';
              separatedBlackCircle.style.opacity = '1';
              grid.appendChild(separatedBlackCircle);
              separatedCircles.push(separatedBlackCircle);
            }
          }
        }
        
        clickCount++;
        const currentTotal = components.slice(0, clickCount).reduce((a, b) => a + b, 0);
        speakNumber(currentTotal);
        
        // Show answer when all components are filled (all dots are colored)
        // Check if we've processed all non-zero components OR if all dots are filled
        const nonZeroComponents = components.filter(c => c > 0);
        const processedNonZero = components.slice(0, clickCount).filter(c => c > 0).length;
        const allDotsFilled = filledCount.count >= square;
        
        if ((clickCount >= totalClicks || processedNonZero >= nonZeroComponents.length || allDotsFilled) && answerDisplay) {
          answerDisplay.textContent = square;
          answerDisplay.classList.add('show');
        }
      }
  });
  
  return section;
}

// Generate squares from 5^2 to 25^2
const moreSquaresContainer = document.getElementById('moreSquares');
if (moreSquaresContainer) {
  // Replace existing 25 section
  const existing25Section = document.querySelector('#square-25')?.closest('.set');
  if (existing25Section) {
    const newSection = generateSquare(5);
    existing25Section.replaceWith(newSection);
  }

  // Generate remaining squares from 6^2 to 25^2
  for (let n = 6; n <= 25; n++) {
    moreSquaresContainer.appendChild(generateSquare(n));
  }
}
</script>

</body>
</html>

